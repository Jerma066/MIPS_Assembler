.data
	#Еазвания Функций был немного изменены, но заверяю вас, что 
	#Рекурсия организована так же, а остальные отличия незначительны.

	#sequence:	.word	'+', 1, 2				#answer is 1 + 2 = 3 (Checked!)
	
	#sequence:	.word	'-', '*', 6, 1, 7			#answer is (1*7) - 6 = 1 (Checked!)
	
	#sequence:	.word	'+', '*', '*', 11, 77, 1, 56		#answer is (11*77) + (56*1) = 903 (Checked!)
	
	#sequence:	.word	'-', '*', '*', 11, 77, 1, 56		#answer is (11*77) - (56*1) = 791 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', '*', '*', 1, 1, 1, 1, 1, 1, 1, 1 						
	#answer is 1*1*1*1*1*1*1*1 = 1 (Checked!)
	
	#sequence:	.word	'-', '*', '*', '*' , '*', '*', '*', 1, 1, 1, 1, 1, 1, 1, 1 
	#answer is 1*1*1*1 - 1*1*1*1 = 0 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 1 
	#answer is 1*1*1*1*1*1 = 1 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 2 
	#answer is 1*1*1*2*1*1 = 2 (Checked!)

	#sequence:	.word	'-', '*', '*', '*' , '*', 2, 1, 1, 1, 1, 1 
	#answer is 1 - 2 = -1 (Checked!)
					
		
	sequence:	.word	'-', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 2 
	#answer is 2 - 1 = 1 (Checked!)
					
	num_of_elems:	.word 	11
	
	space_str:	.asciiz	" " 
.text
main:
	li	$t1,	0
	lw 	$t6,	num_of_elems($t1)
		
	beqz	$t6,	exit_programm
	jal	DF_order_operate
	
exit_programm:
	li	$t3,	0
	lw	$a0,	sequence($t3)	
	#Печать элемента лежащего в a0
	li	$v0,	1	
	syscall
	
	#exit (terminate execution)
	li	$v0,	10
	syscall	
	
DF_order_operate: 
	subu	$sp,	$sp,	8	

	#сохраним в stack указатель на место, из которого была вызвана DF_order_operate  
	#и индекс элемента, в котором мы сейчас находимся, мы делаем это при
	#каждом вызове DF_order_operate = при каждом переходе к следующему элементу
	#так организуется стековый фрейм для рекурсии
	sw	$ra,	0($sp)			
	sw	$t1,	4($sp)

#Левый лист
	#i_ch_l = i_p*2 + 1
	mul	$t1,	$t1,	2	
	add	$t1,	$t1,	1
	
	#Проверка на сущестоввание ребенка. В первом проходе она заводит 
	#нас к листьям дерева. Однако факт перезаписи подгружаемого
	# из стека значения t1 и адреса перехода $ra, их подгрузка
	#Позволяют просто переходить от родителя к ребенку, а не в конец дерева.
	bge	$t1,	$t6,	operate_element_from_stack
	jal	DF_order_operate			#делая jal, мы перезаписываем $ra
	#$ra — содержит адрес инструкции, из которого была вызвана функция.
						
#Правый лист
	#Проходя по правой ветке мы подгружаем значение записанное в стековом фрейме
	#Таким образом мы продолжаем рекурсивное движение от рассматриваемого родителя
	#В сторону не рассмотренного ребенка.
	lw	$t1,	4($sp)
	
	#i_ch_r = i_p*2 + 2
	mul	$t1,	$t1,	2
	add	$t1,	$t1,	2
	
	bge	$t1,	$t6,	operate_element_from_stack
	jal	DF_order_operate		#делая jal, мы перезаписываем $ra
	#$ra — содержит адрес инструкции, из которого была вызвана функция.
					
	#После прохода по правому листу из стекового фрейма вытаскивается значение 
	#которое пререводит нас к позиции переде меткой operate_element_from_stack.
	#Так организован переход от выведенного ребенка
	#К родителю с дальнейшим выводом и его.
					
	
operate_element_from_stack:

	lw 	$t1, 	4($sp)
	mul	$t3,	$t1,	4	
		
	lw	$a0,	sequence($t3)	

	#операции записывают ответ в $a3
	beq	$a0,	43,	sum_a1_a2	#Если в a0 действие делаем действие 
	beq	$a0,	42,	mul_a1_a2	#Если в a0 действие делаем действие 
	beq	$a0,	45,	sub_a1_a2	#Если в a0 действие делаем действие 
	after_operation:
			
	#Подгружаем записанное в stack значение $ra, чтобы продолжить исполнение 
	lw	$ra,	($sp)		#кода с того места, откуда были вызваны.
					# на данном шаге рекурсии. Так, например, после
			#рассмотрнения левого ребенка мы перехоим в рассмотрение правого,
			#из рассмотренного правого - в метку print_element_from_stack 
			#где производится сдвиг стекового фрейма - переход к родителю
					
	#Здесь и работает рекурсия
	add	$sp,	$sp,	8	#По результату выполнения этой строчки происходит  
					#сдвиг $sp - указателя на стековый фрейм, который 
					#определяет в какой участок кода мы попадем
					# и с каким значением работаем.				
	
	#Далее происходит перезапись в DF_order_operate стекового фрейма с тем, чтобы 
	#продолжить рекурсивное движение по нашему дереву.
	
	#Поднявшись до самой верхушки рекурсивной лестницы мы попадем в начало стека, 
	#где, пройдем по $ra,и окажемся перед меткой первого вызова DF_order_operate
	# - exit_programm.
					
	
	#Переход из ранее подгруженного элемента 				
	jr	$ra
	
sum_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
	
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	
	#выполняем операцию
	add	$a3,	$a2,	$a1
	
	sw	$a3,	sequence($t3)
	
	#возвращаемся
	j	after_operation
	
mul_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
		
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	
	#выполняем операцию
	mul	$a3,	$a2,	$a1	
	
	sw	$a3,	sequence($t3)
		
	#возвращаемся
	j	after_operation	
	
sub_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
		
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	 
	#выполняем операцию
	sub	$a3,	$a1,	$a2
	
	sw	$a3,	sequence($t3)
	
	#возвращаемся 
	j	after_operation
	

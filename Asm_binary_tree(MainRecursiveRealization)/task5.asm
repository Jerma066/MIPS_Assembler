.data
	#sequence:	.word	'+', 1, 2				#answer is 1 + 2 = 3 (Checked!)
	
	#sequence:	.word	'-', '*', 6, 1, 7			#answer is (1*7) - 6 = 1 (Checked!)
	
	#sequence:	.word	'+', '*', '*', 11, 77, 1, 56		#answer is (11*77) + (56*1) = 903 (Checked!)
	
	#sequence:	.word	'-', '*', '*', 11, 77, 1, 56		#answer is (11*77) - (56*1) = 791 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', '*', '*', 1, 1, 1, 1, 1, 1, 1, 1 						
	#answer is 1*1*1*1*1*1*1*1 = 1 (Checked!)
	
	#sequence:	.word	'-', '*', '*', '*' , '*', '*', '*', 1, 1, 1, 1, 1, 1, 1, 1 
	#answer is 1*1*1*1 - 1*1*1*1 = 0 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 1 
	#answer is 1*1*1*1*1*1 = 1 (Checked!)
	
	#sequence:	.word	'*', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 2 
	#answer is 1*1*1*2*1*1 = 2 (Checked!)

	#sequence:	.word	'-', '*', '*', '*' , '*', 2, 1, 1, 1, 1, 1 
	#answer is 1 - 2 = -1 (Checked!)
					
		
	sequence:	.word	'-', '*', '*', '*' , '*', 1, 1, 1, 1, 1, 2 
	#answer is 2 - 1 = 1 (Checked!)
					
	num_of_elems:	.word 	11
	
	space_str:	.asciiz	" " 
.text
main:
	li	$t1,	0
	lw 	$t6,	num_of_elems($t1)
		
	beqz	$t6,	exit_programm
	jal	DF_order_print
	
exit_programm:
	li	$t3,	0
	lw	$a0,	sequence($t3)	
	#Печать элемента лежащего в a0
	li	$v0,	1	
	syscall
	
	#exit (terminate execution)
	li	$v0,	10
	syscall	
	
DF_order_print:
	subu	$sp,	$sp,	8	

	#сохраним в stack указатель на место из которого была вызвана DF_order_print и индекс элемента в котором сейчас находимся
	#мы делаем это при каждом вызове DF_order_print = при каждом переходе к следующему элементу
	sw	$ra,	0($sp)			
	sw	$t1,	4($sp)

#Левый лист
	#i_ch_l = i_p*2 + 1
	mul	$t1,	$t1,	2	
	add	$t1,	$t1,	1
	
	#Условие пребывания на последнем уровне
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print			#делая jal, мы перезаписываем $ra
						#$ra — содержит адрес инструкции, из которого была вызвана функция.
						
#Правый лист
	lw	$t1,	4($sp)
	
	#i_ch_r = i_p*2 + 2
	mul	$t1,	$t1,	2
	add	$t1,	$t1,	2
	
	#Условие пребывания на последнем уровне
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print		#делая jal, мы перезаписываем $ra
					#$ra — содержит адрес инструкции, из которого была вызвана функция.
					
	
					
	
print_element_from_stack:
	#Подгружаем со стека индекс текущего элемента, на котором закончился итеративный поиск 
	lw 	$t1, 	4($sp)
	mul	$t3,	$t1,	4	
		
	lw	$a0,	sequence($t3)	

	#операции записывают ответ в $a3
	beq	$a0,	43,	sum_a1_a2	#Если в a0 действие делаем действие 
	beq	$a0,	42,	mul_a1_a2	#Если в a0 действие делаем действие 
	beq	$a0,	45,	sub_a1_a2	#Если в a0 действие делаем действие 
	after_operation:
	
	#Подгружаем последнее записанное в stack значение $ra, чтобы продолжить исполнение кода с того места, откуда были вызваны.
	lw	$ra,	($sp)		#Так как мы сдвигали $sp и записывали туда "свежее значение" $ra.
					#При каждом переходе от родителя к следующему ребенку (по $ra),
					#мы оказываемся на том моменте итерации (перехода от локального корня к листу),
					#на котороый будет смотреть stack pointer ($sp)
					
	
	#Здесь и работает рекурсия
	add	$sp,	$sp,	8	#По результату выполнения этой строчки происходит сдвиг $sp, который
					#определяет в какой участок кода мы попадем и с каким значением работаем.				
	#Таким образом пройдя по левому конечному листу это действие откинет нас 
	#к его общему с правым листом родителю, для которого верна формула #i_ch_r = i_p*2 + 2
	
	#Более того, пройдя один раз до оконца, мы перезаписываем в стеке значение по адресу 0($sp) на значение до последней итерации,
	#Таким образом каждый раз (кроме первого) в  DF_order_print мы делаем шаги не до самых листьев а до детей родителя, который 
	#сейчас рассматривается (смотрим туда, куда указывает $sp), тем временем как для печати подгружаем записанное ранее значение.
	
	#Поднявшись до самой верхушки итеративной лестницы мы попадем в начало стека, где,
	#пройдем по $ra, мы попадем на моменту первого вызова DF_order_print,
	#Что привдет нас к вызову exit_programm.
					
	
	#Переход из ранее подгруженного элемента 				
	jr	$ra
	
sum_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
	
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	
	#выполняем операцию
	add	$a3,	$a2,	$a1
	
	sw	$a3,	sequence($t3)
	
	#возвращаемся
	j	after_operation
	
mul_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
		
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	
	#выполняем операцию
	mul	$a3,	$a2,	$a1	
	
	sw	$a3,	sequence($t3)
		
	#возвращаемся
	j	after_operation	
	
sub_a1_a2:
#у нас есть t1 - это указатель на дествие
	#t4 - указаетль на левого ребенка
	mul	$t4,	$t1,	2	
	add	$t4,	$t4,	1
	mul	$t4,	$t4,	4
	
	#t5 - укаазетль на правкого ребенка
	mul	$t5,	$t1,	2
	add	$t5,	$t5,	2
	mul	$t5,	$t5,	4
		
	#подгуржаем значение из последовательности
	lw	$a1,	sequence($t4)
	lw	$a2,	sequence($t5)
	 
	#выполняем операцию
	sub	$a3,	$a1,	$a2
	
	sw	$a3,	sequence($t3)
	
	#возвращаемся
	j	after_operation
	

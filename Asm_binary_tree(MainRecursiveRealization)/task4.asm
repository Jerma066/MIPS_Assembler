.data
	#sequence:	.word	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,   			#answer is 8 9 4 10 11 5 2 6 7 3 1
	#sequence:	.word	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15  	#answer is 8 9 4 10 11 5 2 12 13 6 14 15 7 3 1
	#sequence:	.word	32, 4, 56, 11, 77, 89				   	#answer is 11 77 4 89 56 32
	#sequence:	.word	32, 4, 56, 11, 77, 89, 67			   	#answer is 11 77 4 89 67 56 32 
	#sequence:	.word	32, 4, 56,				   		#answer is 4 56 32
	sequence:	.word	32, 7				   			#answer is 7 32


	num_of_elems:	.word 	2
	
	space_str:	.asciiz	" " 
.text
main:
	li	$t1,	0
	lw 	$t6,	num_of_elems($t1)
		
	beqz	$t6,	exit_programm
	jal	DF_order_print
	
exit_programm:
	#exit (terminate execution)
	li	$v0,	10
	syscall	
	
DF_order_print:
	subu	$sp,	$sp,	8	

	#сохраним в stack указатель на место из которого была вызвана DF_order_print и индекс элемента в котором сейчас находимся
	#мы делаем это при каждом вызове DF_order_print = при каждом переходе к следующему элементу
	sw	$ra,	0($sp)			
	sw	$t1,	4($sp)

#Левый лист
	#i_ch_l = i_p*2 + 1
	mul	$t1,	$t1,	2	
	add	$t1,	$t1,	1
	
	#Условие пребывания на последнем уровне
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print			#делая jal, мы перезаписываем $ra
						#$ra — содержит адрес инструкции, из которого была вызвана функция.
						
#Правый лист
	lw	$t1,	4($sp)
	
	#i_ch_r = i_p*2 + 2
	mul	$t1,	$t1,	2
	add	$t1,	$t1,	2
	
	#Условие пребывания на последнем уровне
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print		#делая jal, мы перезаписываем $ra
					#$ra — содержит адрес инструкции, из которого была вызвана функция.
					
	
					
	
print_element_from_stack:
	#Подгружаем со стека индекс текущего элемента, на котором закончился итеративный поиск 
	lw 	$t1, 	4($sp)
	mul	$t3,	$t1,	4	
		
	lw	$a0,	sequence($t3)	
	#Печать элемента лежащего в a0
	li	$v0,	1	
	syscall
	
	#Печать символа пробел
	la	$a0,	space_str
	li	$v0,	4
	syscall
	
	#Подгружаем последнее записанное в stack значение $ra, чтобы продолжить исполнение кода с того места, откуда были вызваны.
	lw	$ra,	($sp)		#Так как мы сдвигали $sp и записывали туда "свежее значение" $ra.
					#При каждом переходе от родителя к следующему ребенку (по $ra),
					#мы оказываемся на том моменте итерации (перехода от локального корня к листу),
					#на котороый будет смотреть stack pointer ($sp)
	
	#Здесь и работает рекурсия
	add	$sp,	$sp,	8	#По результату выполнения этой строчки происходит сдвиг $sp, который
					#определяет в какой участок кода мы попадем и с каким значением работаем.				
	#Таким образом пройдя по левому коненому листу это действие откидывает нас 
	#к его общему родителю с правым для которого верна формула #i_ch_r = i_p*2 + 2
	
	#Более того, пройдя один раз до оконца, мы перезаписываем в стеке значение по адресу 0($sp) на значение до последней итерации,
	#Таким образом каждый раз (кроме первого) в  DF_order_print мы делаем шаги не до самых листьев а до детей родителя, которого 
	#сейчас рассматривается (смотрим туда, куда указывает $sp), тем временем как подгружаем для печате итеративно записанное ранее 
	#значени.
	
	#Поднявшись до самой верхушки итеративной лестницы мы попадем в начало стека, где,
	#пройдем по $ra, мы попадем на моменту первого вызова DF_order_print,
	#Что привдет нас к вызову exit_programm.
					
					
	
	
	#Переход из ранее подгруженного элемента 				
	jr	$ra

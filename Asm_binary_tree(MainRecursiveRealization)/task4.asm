.data
	#sequence:	.word	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,   			#answer is 8 9 4 10 11 5 2 6 7 3 1
	#sequence:	.word	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15  	#answer is 8 9 4 10 11 5 2 12 13 6 14 15 7 3 1
	#sequence:	.word	32, 4, 56, 11, 77, 89				   	#answer is 11 77 4 89 56 32
	#sequence:	.word	32, 4, 56, 11, 77, 89, 67			   	#answer is 11 77 4 89 67 56 32 
	#sequence:	.word	32, 4, 56,				   		#answer is 4 56 32
	sequence:	.word	32, 7				   			#answer is 7 32


	num_of_elems:	.word 	2
	
	space_str:	.asciiz	" " 
.text
main:
	li	$t1,	0
	lw 	$t6,	num_of_elems($t1)
		
	beqz	$t6,	exit_programm
	jal	DF_order_print
	
exit_programm:
	#exit (terminate execution)
	li	$v0,	10
	syscall	
	
DF_order_print:
	subu	$sp,	$sp,	8	

	#сохраним в stack указатель на место, из которого была вызвана DF_order_print  
	#и индекс элемента, в котором мы сейчас находимся, мы делаем это при
	#каждом вызове DF_order_print = при каждом переходе к следующему элементу
	#так организуется стековый фрейм для рекурсии
	sw	$ra,	0($sp)			
	sw	$t1,	4($sp)

#Левый лист
	#i_ch_l = i_p*2 + 1
	mul	$t1,	$t1,	2	
	add	$t1,	$t1,	1
	
	#Проверка на сущестоввание ребенка. В первом проходе она заводит 
	#нас к листьям дерева. Однако факт перезаписи подгружаемого
	# из стека значения t1 и адреса перехода $ra, их подгрузка
	#Позволяют просто переходить от родителя к ребенку, а не в конец дерева.
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print			#делая jal, мы перезаписываем $ra
	#$ra — содержит адрес инструкции, из которого была вызвана функция.
						
#Правый лист
	#Проходя по правой ветке мы подгружаем значение записанное в стековом фрейме
	#Таким образом мы продолжаем рекурсивное движение от рассматриваемого родителя
	#В сторону не рассмотренного ребенка.
	lw	$t1,	4($sp)
	
	#i_ch_r = i_p*2 + 2
	mul	$t1,	$t1,	2
	add	$t1,	$t1,	2
	
	bge	$t1,	$t6,	print_element_from_stack
	jal	DF_order_print		#делая jal, мы перезаписываем $ra
	#$ra — содержит адрес инструкции, из которого была вызвана функция.
					
	#После прохода по правому листу из стекового фрейма вытаскивается значение 
	#которое пререводит нас к позиции переде меткой print_element_from_stack.
	#Так организован переход от выведенного ребенка
	#К родителю с дальнейшим выводом и его.
					
	
print_element_from_stack:

	lw 	$t1, 	4($sp)
	mul	$t3,	$t1,	4	
		
	lw	$a0,	sequence($t3)	
	#Печать элемента лежащего в a0
	li	$v0,	1	
	syscall
	
	#Печать символа пробел
	la	$a0,	space_str
	li	$v0,	4
	syscall
	

	#Подгружаем записанное в stack значение $ra, чтобы продолжить исполнение 
	lw	$ra,	($sp)		#кода с того места, откуда были вызваны.
					# на данном шаге рекурсии. Так, например, после
			#рассмотрнения левого ребенка мы перехоим в рассмотрение правого,
			#из рассмотренного правого - в метку print_element_from_stack 
			#где производится сдвиг стекового фрейма - переход к родителю
					
	#Здесь и работает рекурсия
	add	$sp,	$sp,	8	#По результату выполнения этой строчки происходит  
					#сдвиг $sp - указателя на стековый фрейм, который 
					#определяет в какой участок кода мы попадем
					# и с каким значением работаем.				
	
	#Далее происходит перезапись в DF_order_print стекового фрейма с тем, чтобы 
	#продолжить рекурсивное движение по нашему дереву.
	
	#Поднявшись до самой верхушки рекурсивной лестницы мы попадем в начало стека, 
	#где, пройдем по $ra,и окажемся перед меткой первого вызова DF_order_print
	# - exit_programm.
					
	#Переход из ранее подгруженного элемента 				
	jr	$ra

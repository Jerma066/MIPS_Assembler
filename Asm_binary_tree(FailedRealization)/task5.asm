.data
	#sequence:	.word	'+', '*', 56, 11, 77  			#answer is (11*77) + 56 = 903 
	#sequence:	.word	'+', '*', 56, 0, 77  			#answer is (0*77) + 56 = 56
	#sequence:	.word	'+', '*', '*', 11, 77, 1, 56		#answer is (11*77) + (56*1) = 903
	sequence:	.word	'-', '*', 6, 1, 7			#answer is (1*7) - 6 = 1
	exec_seq:	.word	
	num_of_elems:	.word	5
	
.text
	main:
#Number of elements
li	$t1,	0
lw 	$t6,	num_of_elems($t1)

move	$s1,	$t6		#загтовка для контроля элементов в исполнении
mul	$s1,	$s1,	4	#индекс в сиполняемой последоватеьности до которой нужно идти

#-----------Закинем количество уровней в t1-------------------------------
first_step:
li	$t1,	0
li	$t2,	1
	
num_of_levels_in_t1:
	mul	$t2,	$t2,	2
	addi	$t1,	$t1,	1 	
	ble	$t2,	$t6,	num_of_levels_in_t1
#-------------------------------------------------------------------------

#Получим адрес указатель на первый элемент из предпоследней группы 
#Для этого нужно t2 поделить на 2, потом еще на 2, а потом умножить на 4.  
#После чего нужно вычесть одну позицию
move	$t3,	$t2
sub 	$t3,	$t3,	4

#Получим адрес первого элемента из последней группы
#Для этого нужно t2 поделить на 2, а потом умножить на 4 <=> умножить на 2
#После чего нужно вычесть одну позицию
mul	$t2,	$t2,	2
sub 	$t2,	$t2,	4
	
#---Вычисляем количество пар детей на уровне нашего рассмотрнеия---
li	$t4, 	1
sub	$t7,	$t1,	2
num_of_children_on_level_in_t4:
	mul	$t4,	$t4,	2
	sub	$t7,	$t7,	1 
	bgtz	$t7,	num_of_children_on_level_in_t4
	
beq	$t1,	1,	t4_is_0
beq	$t1,	2,	t4_is_1	

continue_after_init_t4:
#------------------------------------------------------------------

#t8 - (указатель на позицую в исполняемой последовательности)*4
#t5 - хранит индекс детей
#t4 - количество пар детей на уровне
#t3 - хранит (индекс родителя)*4
#t2 - хранит (индекс детей)*4
#t1 - хранит номер уровня
#s0 - колчество выведенных элементов

get_items_from_level:

	#Дошли до конца	последовательности -> вышли из вывода детей 
	div,	$t5,	$t2,	4
	bge	$t5,	$t6,	print_parent
		
	#Первый ребенок:
	lw	$a0,	sequence($t2)
	jal	add_a0
	addi	$s0,	$s0,	1	#инкремент выписанных элементов

	#Move на одну  позицию индекса ребенка
	addi	$t2,	$t2,	4
	
	#Дошли до конца	последовательности -> вышли из вывода детей 
	div,	$t5,	$t2,	4
	bge	$t5,	$t6,	print_parent

	#Второй ребенок:
	lw	$a0,	sequence($t2)
	jal	add_a0
	addi	$s0,	$s0,	1	#инкремент выписанных элементов
	
	#Move на одну  позицию индекса ребенка
	addi	$t2,	$t2,	4
	
	
	print_parent:
		#Родитель
		lw	$a0,	sequence($t3)
		jal	add_a0
		addi	$s0,	$s0,	1	#инкремент выписанных элементов

		#Move на одну  позицию индекса родителя и ребенка
		addi	$t3,	$t3,	4
	
		#Деркемент количества пар детей
		sub	$t4,	$t4,	1
	
		#Если число пар детей не 0, продолжаем: 
		bgtz 	$t4,	get_items_from_level
	
out_from_out_getting_level_items:
	sub 	$t1,	$t1,	2				#уменьшаем номер уровня на 2
	sub	$t6,	$t6,	$s0				#вычитаем из общего числа количество выписаннны элементов
	li	$s0,	0					#обнуляем счтчик выписанных элементов
	beq	$t6,	0,	execute_binary_tree		#если элементы все выведены заканчиваем исполнение
	ble	$t1,	1,	add_root			#если оказались на первом уровне, печатаем первый элемент

	bge	$t6,	3,	first_step
	
add_root:
	li	$t3,	0
	lw	$a0,	sequence($t3)
	jal	add_a0
	
execute_binary_tree:
	#t1 - (индекс элемента исполняемой последовательности)*4
	#a1 - первое число из последовательности, над которым соверашется дествие
	#a2 - второе число из последовательности над которым выполняется действие
	#a3 - хранит результат действия
	#t2 - хранит действие
	#t3 - хранит результат последнего действия
	
	li,	$t1,	0
	
	#Первые два всегда числа, третье всегда операция, иначе дерево некоректно
	lw	$a1,	exec_seq($t1)	#получаем первое число над которым будет выполняться действие
	addi	$t1,	$t1,	4	#двигаем указатель по исполняемой последователности
	
	lw	$a2,	exec_seq($t1)	#получаем второе число над которым будет выполняться действие
	addi	$t1,	$t1,	4	#двигаем указатель по исполняемой последователности
	
	lw	$t2,	exec_seq($t1)	#получаем операцию которая, будет выполняться
	#здесь двигать индекс исполняемой полуследовательность не будем, потому что хотим перезаписать ту поцизиу, в которой хранится этот знак
	
	beq	$t2,	43,	sum_a1_a2	
	beq	$t2,	42,	mul_a1_a2
	beq	$t2,	45,	sub_a1_a2
	
	make_operations:
		find_operation:
			#получаем первое число из последовательности
			sub	$t1,	$t1,	8
			lw	$a1,	exec_seq($t1)
			
			#получаем второе число из последовательности
			addi	$t1,	$t1,	4
			lw	$a2,	exec_seq($t1)	
			
			#возвращаем каретку на место
			addi	$t1,	$t1,	4	
			
		
			lw	$t2,	exec_seq($t1)		#получаем операцию которая, будет выполняться
			
			beq	$t2,	43,	sum_a1_a2	#Если на действие делаем действие 
			beq	$t2,	42,	mul_a1_a2	#Если на действие делаем действие 
			beq	$t2,	45,	sub_a1_a2	#Если на действие делаем действие 

			bge	$t1,	$s1,	exit_programm	#Если мы в конце нашей исполняемой последовательности, выходим
			addi	$t1,	$t1,	4		#двигаем указатель по исполняемой последователности
			
			j find_operation
	  	
	  	after_operation:
	  	
	  	bge	$t1,	$s1,	exit_programm
	  	j	make_operations
	  	
#---Служебные функциии------------------------------------------------
exit_programm:
	sub,	$t1,	$t1,	4
	lw,	$a0,	exec_seq($t1)		#вытягиваем то, до чего дошли
	#Выполняем печать a0
	li	$v0,	1			
	syscall	

	#exit (terminate execution)
	li	$v0,	10
	syscall	
	
sum_a1_a2:
	add	$a3,	$a2,	$a1
	sw,	$a3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию
	
	#выгружаем предыдущий результат перед новополучнным значением, запоминаем полученнный результат
	sub	$t1,	$t1,	4
	sw,	$t3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию
	add	$t1,	$t1,	4
	move	$t3,	$a3			#запоминание памяти 
	
	j	after_operation
	
mul_a1_a2:
	mul	$a3,	$a2,	$a1		
	sw,	$a3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию

	#выгружаем предыдущий результат перед новополучнным значением, запоминаем полученнный результат
	sub	$t1,	$t1,	4
	sw,	$t3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию
	add	$t1,	$t1,	4
	move	$t3,	$a3			#запоминание памяти 
	
	j	after_operation	
	
sub_a1_a2:
	sub	$a3,	$a1,	$a2
	sw,	$a3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию
	
	#выгружаем предыдущий результат перед новополучнным значением, запоминаем полученнный результат
	sub	$t1,	$t1,	4
	sw,	$t3,	exec_seq($t1)		#кидаем резульат в то место, откуда считали операцию
	add	$t1,	$t1,	4
	move	$t3,	$a3			#запоминание памяти 
	
	j	after_operation
	
t4_is_0:
	li,	$t4,	0
	j	continue_after_init_t4

t4_is_1:
	li,	$t4,	1
	j	continue_after_init_t4
	
add_a0:
	sw	$a0,	exec_seq($t8)
	addi	$t8,	$t8,	4	 #сдвиг записи в исполняемую последовательность
	jr	$ra	
	
print_a0:
	#Printing an integer element in a0 register as a decimal number
	li	$v0,	1	
	syscall
	jr	$ra	
